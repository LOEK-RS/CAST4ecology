---
title: "CAST4Ecology Modelling Tutorial"
execute: 
  warning: false
  message: false
---




## Preparations

### Needed R Packages

```{r libraries}
#| message: false
#| warning: false

# for (spatial) data handling
library(terra)
library(sf)
library(tidyverse)

# modelling
library(caret)
library(CAST)
library(ranger)

# visuals
library(tmap)
library(viridis)
library(scales)
library(ggpubr)

```

### Example data

```{r data}
## Wording from now on:
# reference_points: predictors + response + coordinates + metadata
# training_data: reference samples without coordinates
# predictors: spatially continuous predictor stack
# modeldomain: where we want to predict (the outline of South America)
# predictor_names: names of predictors in the training_data and the predictor stack
# response_name: name of the response variable in plots


predictors <- rast("data/predictors.tif")
reference_points <- st_read("data/training_data.gpkg")
training_data <- reference_points |> st_drop_geometry() # reference samples without coordinates
modeldomain <- st_read("data/modeldomain.gpkg")



### Patch: less predictors
p = c("bio_1", "bio_4", "bio_5", "bio_6", "bio_8", "bio_9", "bio_12", "bio_13", "bio_14", "bio_15", "elev")
predictors = predictors[[p]]

predictor_names <- names(predictors)
response_name <- "Species_richness"

# define color palette
Okabe_Ito <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#CC79A7") 
```


```{r response}
tm_shape(modeldomain)+
    tm_borders()+
    tm_shape(reference_points)+
    tm_symbols(col = "Species_richness", style = "cont",
               legend.col.reverse = TRUE,
               palette = plasma(50, direction = -1),
               size = 0.2, title.col = "Species richness")+
    tm_layout(frame = FALSE)
```


```{r predictors}
p = predictors[[c("bio_4", "bio_12", "bio_8", "elev")]]
names(p) = c("Temp. Seasonality", "Annual Precipitation", "Temp. wettest quarter", "Elevation")

tm_shape(p)+
    tm_raster(style = "cont", title = "", legend.reverse = TRUE)+
    tm_facets(free.scales = TRUE, ncol = 2)+
    tm_layout(legend.position = c("right", "bottom"),
              legend.just = "left",
              panel.show = TRUE,
              panel.labels = names(p),
              panel.label.bg.color = NA,
              frame.lwd = NA,
              frame = FALSE)
```



## A first simple prediction model

```{r rcv-model}
set.seed(6502)
rfmodel_rcv <- caret::train(x = training_data |> select(all_of(predictor_names)),
                            y = training_data |> pull(response_name),
                            method = "ranger",
                            num.trees = 100,
                            trControl = trainControl(method = "cv",
                                                     savePredictions = TRUE))

prediction_rcv <- predict(predictors, rfmodel_rcv, na.rm = TRUE)
```


```{r rcv-prediction}
#| code-fold: true
#| code-summary: "knndm-cv visualization with tmap and ggplot2"
tm_shape(prediction_rcv)+
    tm_raster(title = "Predicted \nSpecies Richness", style = "cont",
              palette = mako(50, begin = 0.2),
              legend.reverse = TRUE)+
        tm_layout(legend.position = c("right", "bottom"),
              legend.just = "left",
              frame = FALSE)
```



## Cross-validation to estimate the map accuracy


```{r geodist}
geo_distance = plot_geodist(reference_points, modeldomain, showPlot = FALSE)
geo_distance$plot + 
    scale_y_continuous(expand = c(0,0))+
    scale_x_continuous(expand = c(0,0),
                       trans = "log10",
                       labels = trans_format("log10", math_format(10^.x)))+
    theme_light()+
    theme(legend.position = "bottom")
```


### Setting up knndm-cv

* setting up cv folds such that between-folds distance matches sample-prediction distance
* cv more representative of actual prediction task

```{r knndm-setup}
knndm_folds = CAST::knndm(tpoints = reference_points,
                        modeldomain = modeldomain, 
                        samplesize = 4000, k = 5)

reference_points$fold = knndm_folds$clusters
reference_points$random_fold = sample(seq(5),
                                      size = nrow(reference_points),
                                      replace = TRUE) ## imitating a random 5 fold cross validation
```

```{r rcv-plots}
#| code-fold: true
#| code-summary: "knndm-cv visualization with tmap and ggplot2"
#| layout-ncol: 2


tm_shape(modeldomain)+
    tm_borders()+
    tm_shape(reference_points)+
    tm_symbols(col = "random_fold", style = "cat",
               legend.col.reverse = FALSE,
               palette = Okabe_Ito,
               size = 0.2, title.col = "Random Folds",
               legend.col.is.portrait = FALSE)+
    tm_layout(frame = FALSE)



plot_geodist(reference_points,
                  modeldomain,
                  cvfolds = reference_points$random_fold,
                  showPlot = FALSE)
plot_rcv = gd_rcv$plot + 
    scale_y_continuous(expand = c(0,0))+
    scale_x_continuous(expand = c(0,0),
                       trans = "log10",
                       labels = trans_format("log10", math_format(10^.x)))+
    theme_light()+
    theme(legend.position = "bottom")


rcv_ecdf <- plot_geodist(reference_points, modeldomain, cvfolds = reference_points$random_fold, stat = "ecdf", showPlot = FALSE)
rcv_ecdf$plot + 
  scale_x_continuous(limits = c(0,1500000))+
  theme_light()+
  theme(legend.position = "bottom")

```


```{r knndm-plots}
tm_shape(modeldomain)+
    tm_borders()+
    tm_shape(reference_points)+
    tm_symbols(col = "fold", style = "cat",
               legend.col.reverse = FALSE,
               palette = Okabe_Ito,
               size = 0.2, title.col = "knndm Folds",
               legend.col.is.portrait = FALSE)+
    tm_layout(frame = FALSE)



gd = plot_geodist(reference_points,
                  modeldomain,
                  cvfolds = reference_points$fold,
                  showPlot = FALSE)
gd$plot + 
    scale_y_continuous(expand = c(0,0))+
    scale_x_continuous(expand = c(0,0),
                       trans = "log10",
                       labels = trans_format("log10", math_format(10^.x)))+
    theme_light()+
    theme(legend.position = "bottom")


knndmcv_ecdf <- plot_geodist(reference_points, modeldomain, cvfolds = knndm_folds$clusters, stat = "ecdf", showPlot = FALSE)
knndmcv_ecdf$plot + 
  scale_x_continuous(limits = c(0,1500000))+
  theme_light()+
  theme(legend.position = "bottom")


```





### Random Forest Model with knndm-cv

```{r knndm-model}

tr_control <- trainControl(method = "cv",
                         number = 5,
                         index = knndm_folds$indx_train,
                         savePredictions = TRUE)


set.seed(51)
rfmodel_knndmcv <- caret::train(x = training_data[,predictor_names],
                           y = training_data[,response_name],
                           method = "ranger",
                           num.trees = 100,
                           trControl = tr_control)

global_validation(rfmodel_knndmcv)

```



## Spatial model tuning and feature selection


* simplify the model by selecting predictors based on their performance in new regions
* new regions are defined by spatial cv folds (here knndm approach)
* runtime ~ 10 min


```{r ffs}
set.seed(65)
rfmodel_ffs <- CAST::ffs(training_data[,predictor_names],
                         training_data[,response_name],
                         method = "ranger",
                         importance = "permutation",
                         num.trees = 100,
                         trControl = tr_control)
prediction_ffs <- predict(predictors, rfmodel_ffs, na.rm = TRUE)
global_validation(rfmodel_ffs)
plot(rfmodel_ffs, plotType = "selected")

```



```{r ffs-prediction}

tm_shape(prediction_ffs)+
    tm_raster(title = "Predicted \nSpecies Richness", style = "cont",
              palette = mako(50, begin = 0.2),
              legend.reverse = TRUE)+
        tm_layout(legend.position = c("right", "bottom"),
              legend.just = "left",
              frame = FALSE)
```


```{r ffs-selected}

# TODO


```



## Assessment of the area of applicability


```{r knndm-aoa}
AOA = CAST::aoa(predictors, model = rfmodel_ffs)
```


```{r knndm-mapping}
#| code-fold: true
#| code-summary: "Map creation with tmap"

tm_shape(AOA$DI)+
    tm_raster(palette = viridis(50), style = "cont", legend.reverse = TRUE, breaks = c(0,0.1,0.282,0.5,1))+
            tm_layout(legend.position = c("right", "bottom"),
              legend.just = "left",
              frame = FALSE)


tm_shape(prediction_ffs)+
    tm_raster(title = "Predicted \nSpecies Richness", style = "cont",
              palette = mako(50, begin = 0.2),
              legend.reverse = TRUE)+
    tm_shape(AOA$AOA)+
    tm_raster(palette = c("1" = NA, "0" = "darkgoldenrod1"), style = "cat", legend.show = FALSE)+
    tm_add_legend(type = "fill", col = "darkgoldenrod1", border.lwd = 0,labels = "Outside AOA")+
        tm_layout(legend.position = c("right", "bottom"),
              legend.just = "left",
              frame = FALSE)
```





```{r model-comparison}
#| eval: true
#| code-fold: true
#| code-summary: "Compare Model Results"

cv_results = rbind(global_validation(rfmodel_rcv),
    global_validation(rfmodel_knndmcv),
    global_validation(rfmodel_ffs)) |> 
    as.data.frame() |> mutate("CV" = c("random", "knndm", "knndm"),
                              "predictors" = c(ncol(rfmodel_rcv$trainingData)-1,
                                               ncol(rfmodel_knndmcv$trainingData)-1, 
                                               ncol(rfmodel_ffs$trainingData)-1))
knitr::kable(cv_results)
```




## Pixel-wise performance estimation

```{r calibrate}
#| eval: true
#| cache: true
set.seed(10)
expected_perf = calibrate_aoa(AOA, rfmodel_ffs)
```


```{r calibrate-mapping}
#| code-fold: true
#| code-summary: "Map creation with tmap"


tm_shape(expected_perf$AOA$expected_RMSE)+
    tm_raster(title = "Expected \nRMSE",style = "cont", legend.reverse = TRUE, palette = mako(50, direction = -1))+
    tm_shape(expected_perf$AOA$AOA)+
    tm_raster(palette = c("1" = NA, "0" = "darkgoldenrod1"), style = "cat", legend.show = FALSE)+
    tm_add_legend(type = "fill", col = "darkgoldenrod1", border.lwd = 0,labels = "Outside AOA")+
            tm_layout(legend.position = c("right", "bottom"),
              legend.just = "left",
              frame = FALSE)
```



